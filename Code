// Définition des constantes
#define MAX_FILENAME 50
#define MAX_FILES 100
#define MAX_RECORDS 1000

// Structure pour un enregistrement
typedef struct {
    int id;
    // Ajoutez d'autres champs selon vos besoins
    char isDeleted;  // Pour la suppression logique
} Record;

// Structure pour les métadonnées
typedef struct {
    char filename[MAX_FILENAME];
    int numBlocks;
    int numRecords;
    int firstBlockAddress;
    char globalOrganization;  // 'C' pour contiguë, 'L' pour chaînée
    char internalOrganization;  // 'T' pour trié, 'N' pour non-trié
} Metadata;

// Structure pour un bloc
typedef struct {
    Record* records;
    int numRecords;
    int nextBlock;  // Pour l'organisation chaînée
    char filename[MAX_FILENAME];  // Pour identifier à quel fichier appartient le bloc
} Block;

// Structure principale pour la mémoire secondaire
typedef struct {
    Block* blocks;
    int totalBlocks;

// Fonction d'initialisation de la mémoire secondaire
void initializeSecondaryMemory(SecondaryMemory* sm, int numBlocks, int blockSize) {
    sm->totalBlocks = numBlocks;
    sm->blockSize = blockSize;
    sm->numFiles = 0;
    
    // Allocation de la table d'allocation
    sm->allocationTable = (char*)malloc(numBlocks * sizeof(char));
    for(int i = 0; i < numBlocks; i++) {
        sm->allocationTable[i] = '0';  // Tous les blocs sont libres
    }
    
    // Allocation des blocs
    sm->blocks = (Block*)malloc(numBlocks * sizeof(Block));
    for(int i = 0; i < numBlocks; i++) {
        sm->blocks[i].records = (Record*)malloc(blockSize * sizeof(Record));
        sm->blocks[i].numRecords = 0;
        sm->blocks[i].nextBlock = -1;
    }
    
    // Allocation du tableau de métadonnées
    sm->fileMetadata = (Metadata*)malloc(MAX_FILES * sizeof(Metadata));
}

// Fonction pour créer un nouveau fichier
int createFile(SecondaryMemory* sm, const char* filename, int numRecords, 
               char globalOrg, char internalOrg) {
    if(sm->numFiles >= MAX_FILES) {
        printf("Erreur: Nombre maximum de fichiers atteint\n");
        return -1;
    }
    
    // Calcul du nombre de blocs nécessaires
    int blocksNeeded = (numRecords + sm->blockSize - 1) / sm->blockSize;
    
    // Vérification de l'espace disponible
    int freeBlocks = 0;
    for(int i = 0; i < sm->totalBlocks; i++) {
        if(sm->allocationTable[i] == '0') freeBlocks++;
    }
    
    if(freeBlocks < blocksNeeded) {
        printf("Erreur: Espace insuffisant\n");
        return -1;
    }
    
    // Création des métadonnées
    Metadata* meta = &sm->fileMetadata[sm->numFiles];
    strcpy(meta->filename, filename);
    meta->numBlocks = blocksNeeded;
    meta->numRecords = numRecords;
    meta->globalOrganization = globalOrg;
    meta->internalOrganization = internalOrg;
    
    // Allocation des blocs selon l'organisation
    if(globalOrg == 'C') {
        // Organisation contiguë
        int startBlock = -1;
        int consecutiveBlocks = 0;
        
        // Recherche de blocs contigus
        for(int i = 0; i < sm->totalBlocks; i++) {
            if(sm->allocationTable[i] == '0') {
                if(startBlock == -1) startBlock = i;
                consecutiveBlocks++;
                if(consecutiveBlocks == blocksNeeded) break;
            } else {
                startBlock = -1;
                consecutiveBlocks = 0;
            }
        }
        
        if(consecutiveBlocks < blocksNeeded) {
            printf("Erreur: Fragmentation, compactage necessaire\n");
            return -1;
        }
        
        // Allocation des blocs
        meta->firstBlockAddress = startBlock;
        for(int i = 0; i < blocksNeeded; i++) {
            sm->allocationTable[startBlock + i] = '1';
            strcpy(sm->blocks[startBlock + i].filename, filename);
        }
    } else {
        // Organisation chaînée
        int firstBlock = -1;
        int prevBlock = -1;
        int allocatedBlocks = 0;
        
        for(int i = 0; i < sm->totalBlocks && allocatedBlocks < blocksNeeded; i++) {
            if(sm->allocationTable[i] == '0') {
                sm->allocationTable[i] = '1';
                strcpy(sm->blocks[i].filename, filename);
                
                if(firstBlock == -1) firstBlock = i;
                if(prevBlock != -1) {
                    sm->blocks[prevBlock].nextBlock = i;
                }
                prevBlock = i;
                allocatedBlocks++;
            }
        }
        
        meta->firstBlockAddress = firstBlock;
        sm->blocks[prevBlock].nextBlock = -1;
    }
    
    sm->numFiles++;
    return 0;
} 
// Fonction pour la suppression logique d'un enregistrement
void deleteRecordLogical(SecondaryMemory* sm, const char* filename, int id) {
    // Recherche des métadonnées du fichier
    int fileIndex = -1;
    for(int i = 0; i < sm->numFiles; i++) {
        if(strcmp(sm->fileMetadata[i].filename, filename) == 0) {
            fileIndex = i;
            break;
        }
    }
    
    if(fileIndex == -1) {
        printf("Erreur: Fichier non trouve\n");
        return;
    }
    
    Metadata* meta = &sm->fileMetadata[fileIndex];
    int currentBlock = meta->firstBlockAddress;
    
    while(currentBlock != -1) {
        Block* block = &sm->blocks[currentBlock];
        
        // Recherche dans le bloc
        for(int i = 0; i < block->numRecords; i++) {
            if(block->records[i].id == id) {
                block->records[i].isDeleted = 1;
                printf("Enregistrement marque comme supprime\n");
                return;
            }
        }
        
        // Passage au bloc suivant
        if(meta->globalOrganization == 'C') {
            currentBlock++;
            if(currentBlock >= meta->firstBlockAddress + meta->numBlocks) break;
        } else {
            currentBlock = sm->blocks[currentBlock].nextBlock;
        }
    }
    
    printf("Enregistrement non trouve\n");
}

// Fonction pour le compactage de la mémoire secondaire
void compactMemory(SecondaryMemory* sm) {
    // Création d'une copie temporaire des métadonnées
    Metadata* tempMetadata = (Metadata*)malloc(sm->numFiles * sizeof(Metadata));
    memcpy(tempMetadata, sm->fileMetadata, sm->numFiles * sizeof(Metadata));
    
    // Réinitialisation de la table d'allocation
    for(int i = 0; i < sm->totalBlocks; i++) {
        sm->allocationTable[i] = '0';
    }
    
    // Déplacement des fichiers vers le début
    int currentBlock = 0;
    for(int i = 0; i < sm->numFiles; i++) {
        Metadata* meta = &tempMetadata[i];
        int oldFirstBlock = meta->firstBlockAddress;
        meta->firstBlockAddress = currentBlock;
        
        // Copie des blocs
        if(meta->globalOrganization == 'C') {
            // Organisation contiguë
            for(int j = 0; j < meta->numBlocks; j++) {
                memcpy(&sm->blocks[currentBlock + j], 
                       &sm->blocks[oldFirstBlock + j], 
                       sizeof(Block));
                sm->allocationTable[currentBlock + j] = '1';
            }
        } else {
            // Organisation chaînée
            int oldBlock = oldFirstBlock;
            int newBlock = currentBlock;
            
            while(oldBlock != -1) {
                memcpy(&sm->blocks[newBlock], 
                       &sm->blocks[oldBlock], 
                       sizeof(Block));
                sm->allocationTable[newBlock] = '1';
                
                if(sm->blocks[oldBlock].nextBlock != -1) {
                    sm->blocks[newBlock].nextBlock = newBlock + 1;
                    newBlock++;
                }
                oldBlock = sm->blocks[oldBlock].nextBlock;
            }
            currentBlock = newBlock;
        }
        
        currentBlock += meta->numBlocks;
    }
    
    // Mise à jour des métadonnées
    memcpy(sm->fileMetadata, tempMetadata, sm->numFiles * sizeof(Metadata));
    free(tempMetadata);
}
// Fonction pour afficher l'état de la mémoire secondaire
void displayMemoryState(SecondaryMemory* sm) {
    printf("\nEtat de la memoire secondaire:\n");
    for(int i = 0; i < sm->totalBlocks; i++) {
        if(sm->allocationTable[i] == '0') {
            printf("\033[32m[Libre]\033[0m ");  // Vert pour les blocs libres
        } else {
            printf("\033[31m[%s-%d]\033[0m ", 
                   sm->blocks[i].filename, 
                   sm->blocks[i].numRecords);  // Rouge pour les blocs occupés
        }
        if((i + 1) % 5 == 0) printf("\n");  // 5 blocs par ligne
    }
    printf("\n");
}
// Fonction pour afficher les métadonnées
void displayMetadata(SecondaryMemory* sm) {
    printf("\nMetadonnées des fichiers:\n");
    printf("%-20s %-10s %-15s %-15s %-20s %-20s\n",
           "Nom", "Blocs", "Enregistrements", "Premier bloc", "Org. Globale", "Org. Interne");
    printf("--------------------------------------------------------------------------------\n");
    
    for(int i = 0; i < sm->numFiles; i++) {
        Metadata* meta = &sm->fileMetadata[i];
        printf("%-20s %-10d %-15d %-15d %-20c %-20c\n",
               meta->filename,
               meta->numBlocks,
               meta->numRecords,
               meta->firstBlockAddress,
               meta->globalOrganization,
               meta->internalOrganization);
    }
}

// Fonction pour la suppression physique d'un enregistrement
void deleteRecordPhysical(SecondaryMemory* sm, const char* filename, int id) {
    int fileIndex = -1;
    for(int i = 0; i < sm->numFiles; i++) {
        if(strcmp(sm->fileMetadata[i].filename, filename) == 0) {
            fileIndex = i;
            break;
        }
    }
    
    if(fileIndex == -1) {
        printf("Erreur: Fichier non trouve\n");
        return;
    }
    
    Metadata* meta = &sm->fileMetadata[fileIndex];
    int currentBlock = meta->firstBlockAddress;
    int found = 0;
    
    while(currentBlock != -1 && !found) {
        Block* block = &sm->blocks[currentBlock];
        
        for(int i = 0; i < block->numRecords; i++) {
            if(block->records[i].id == id) {
                // Suppression physique - décalage des enregistrements
                for(int j = i; j < block->numRecords - 1; j++) {
                    block->records[j] = block->records[j + 1];
                }
                block->numRecords--;
                meta->numRecords--;
                found = 1;
                break;
            }
        }
        
        if(meta->globalOrganization == 'C') {
            currentBlock++;
            if(currentBlock >= meta->firstBlockAddress + meta->numBlocks) break;
        } else {
            currentBlock = sm->blocks[currentBlock].nextBlock;
        }
    }
    
    if(found) {
        printf("Enregistrement supprime physiquement\n");
    } else {
        printf("Enregistrement non trouve\n");
    }
}

// Fonction pour défragmenter un fichier
void defragmentFile(SecondaryMemory* sm, const char* filename) {
    int fileIndex = -1;
    for(int i = 0; i < sm->numFiles; i++) {
        if(strcmp(sm->fileMetadata[i].filename, filename) == 0) {
            fileIndex = i;
            break;
        }
    }
    
    if(fileIndex == -1) {
        printf("Erreur: Fichier non trouve\n");
        return;
    }
    
    Metadata* meta = &sm->fileMetadata[fileIndex];
    
    // Création d'un tableau temporaire pour stocker les enregistrements valides
    Record* tempRecords = (Record*)malloc(meta->numRecords * sizeof(Record));
    int validCount = 0;
